// @generated
// This file is @generated by prost-build.
/// GenesisState defines the capability module's genesis state.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenesisState {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProtoInt64 {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProtoUint64 {
    #[prost(uint64, tag = "1")]
    pub value: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoAccAddresses {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoStrings {
    #[prost(string, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBools {
    #[prost(bool, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddLiquidity {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub asset_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub affiliate_address: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub affiliate_basis_points: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "9")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBan {
    #[prost(bytes = "vec", tag = "2")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBond {
    #[prost(message, optional, tag = "1")]
    pub tx_in: ::core::option::Option<super::common::Tx>,
    #[prost(bytes = "vec", tag = "2")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub bond: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub bond_address: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub bond_provider_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "7")]
    pub operator_fee: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxOutItem {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub vault_pub_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub coin: ::core::option::Option<super::common::Coin>,
    #[prost(string, tag = "5")]
    pub memo: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub max_gas: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(int64, tag = "7")]
    pub gas_rate: i64,
    #[prost(string, tag = "8")]
    pub in_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub out_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub module_name: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub aggregator: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub aggregator_target_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub aggregator_target_limit: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub clout_spent: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxOut {
    #[prost(int64, tag = "1")]
    pub height: i64,
    #[prost(message, repeated, tag = "2")]
    pub tx_array: ::prost::alloc::vec::Vec<TxOutItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObservedTx {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(enumeration = "Status", tag = "2")]
    pub status: i32,
    #[prost(string, repeated, tag = "3")]
    pub out_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub block_height: i64,
    #[prost(string, repeated, tag = "5")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub observed_pub_key: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub keysign_ms: i64,
    #[prost(int64, tag = "8")]
    pub finalise_height: i64,
    #[prost(string, tag = "9")]
    pub aggregator: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub aggregator_target: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub aggregator_target_limit: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObservedTxVoter {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tx: ::core::option::Option<ObservedTx>,
    #[prost(int64, tag = "3")]
    pub height: i64,
    #[prost(message, repeated, tag = "4")]
    pub txs: ::prost::alloc::vec::Vec<ObservedTx>,
    #[prost(message, repeated, tag = "5")]
    pub actions: ::prost::alloc::vec::Vec<TxOutItem>,
    #[prost(message, repeated, tag = "6")]
    pub out_txs: ::prost::alloc::vec::Vec<super::common::Tx>,
    #[prost(int64, tag = "7")]
    pub finalised_height: i64,
    #[prost(bool, tag = "8")]
    pub updated_vault: bool,
    #[prost(bool, tag = "9")]
    pub reverted: bool,
    #[prost(int64, tag = "10")]
    pub outbound_height: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Status {
    Incomplete = 0,
    Done = 1,
    Reverted = 2,
}
impl Status {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Incomplete => "incomplete",
            Self::Done => "done",
            Self::Reverted => "reverted",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "incomplete" => Some(Self::Incomplete),
            "done" => Some(Self::Done),
            "reverted" => Some(Self::Reverted),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgConsolidate {
    #[prost(message, optional, tag = "1")]
    pub observed_tx: ::core::option::Option<ObservedTx>,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDeposit {
    #[prost(message, repeated, tag = "1")]
    pub coins: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(string, tag = "2")]
    pub memo: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDonate {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub asset_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rune_amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgErrataTx {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgLeave {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(bytes = "vec", tag = "2")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgLoanOpen {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub collateral_asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub collateral_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub target_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub target_asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "6")]
    pub min_out: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub affiliate_address: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub affiliate_basis_points: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub aggregator: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub aggregator_target_address: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub aggregator_target_limit: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "12")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "13")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgLoanRepayment {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub collateral_asset: ::core::option::Option<super::common::Asset>,
    #[prost(message, optional, tag = "3")]
    pub coin: ::core::option::Option<super::common::Coin>,
    #[prost(string, tag = "4")]
    pub min_out: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "6")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgManageThorName {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub coin: ::core::option::Option<super::common::Coin>,
    #[prost(int64, tag = "5")]
    pub expire_block_height: i64,
    #[prost(message, optional, tag = "6")]
    pub preferred_asset: ::core::option::Option<super::common::Asset>,
    #[prost(bytes = "vec", tag = "7")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMigrate {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<ObservedTx>,
    #[prost(int64, tag = "2")]
    pub block_height: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMimir {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub value: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgNetworkFee {
    #[prost(int64, tag = "1")]
    pub block_height: i64,
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub transaction_size: u64,
    #[prost(uint64, tag = "4")]
    pub transaction_fee_rate: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgNodePauseChain {
    #[prost(int64, tag = "1")]
    pub value: i64,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgNoOp {
    #[prost(message, optional, tag = "1")]
    pub observed_tx: ::core::option::Option<ObservedTx>,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub action: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgObservedTxIn {
    #[prost(message, repeated, tag = "1")]
    pub txs: ::prost::alloc::vec::Vec<ObservedTx>,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgObservedTxOut {
    #[prost(message, repeated, tag = "1")]
    pub txs: ::prost::alloc::vec::Vec<ObservedTx>,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRagnarok {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<ObservedTx>,
    #[prost(int64, tag = "2")]
    pub block_height: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRefundTx {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<ObservedTx>,
    #[prost(string, tag = "2")]
    pub in_tx_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReserveContributor {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgReserveContributor {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub contributor: ::core::option::Option<ReserveContributor>,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRunePoolDeposit {
    #[prost(bytes = "vec", tag = "1")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub tx: ::core::option::Option<super::common::Tx>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRunePoolWithdraw {
    #[prost(bytes = "vec", tag = "1")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(string, tag = "3")]
    pub basis_points: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub affiliate_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub affiliate_basis_points: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSecuredAssetDeposit {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSecuredAssetWithdraw {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSend {
    #[prost(bytes = "vec", tag = "1")]
    pub from_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub to_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub amount: ::prost::alloc::vec::Vec<super::cosmos::base::v1beta1::Coin>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetIpAddress {
    #[prost(string, tag = "1")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetNodeKeys {
    #[prost(message, optional, tag = "1")]
    pub pub_key_set_set: ::core::option::Option<super::common::PubKeySet>,
    #[prost(string, tag = "2")]
    pub validator_cons_pub_key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSolvency {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub coins: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(int64, tag = "5")]
    pub height: i64,
    #[prost(bytes = "vec", tag = "6")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSwap {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub target_asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub destination: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub trade_target: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub affiliate_address: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub affiliate_basis_points: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "7")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "8")]
    pub aggregator: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub aggregator_target_address: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub aggregator_target_limit: ::prost::alloc::string::String,
    #[prost(enumeration = "OrderType", tag = "11")]
    pub order_type: i32,
    #[prost(uint64, tag = "12")]
    pub stream_quantity: u64,
    #[prost(uint64, tag = "13")]
    pub stream_interval: u64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderType {
    Market = 0,
    Limit = 1,
}
impl OrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Market => "market",
            Self::Limit => "limit",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "market" => Some(Self::Market),
            "limit" => Some(Self::Limit),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTradeAccountDeposit {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTradeAccountWithdrawal {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(string, tag = "1")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub blame_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub blame_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blame {
    #[prost(string, tag = "1")]
    pub fail_reason: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_unicast: bool,
    #[prost(message, repeated, tag = "3")]
    pub blame_nodes: ::prost::alloc::vec::Vec<Node>,
    #[prost(string, tag = "4")]
    pub round: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTssKeysignFail {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub height: i64,
    #[prost(message, optional, tag = "3")]
    pub blame: ::core::option::Option<Blame>,
    #[prost(string, tag = "4")]
    pub memo: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub coins: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(string, tag = "6")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "7")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Keygen {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "KeygenType", tag = "2")]
    pub r#type: i32,
    #[prost(string, repeated, tag = "3")]
    pub members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeygenBlock {
    #[prost(int64, tag = "1")]
    pub height: i64,
    #[prost(message, repeated, tag = "4")]
    pub keygens: ::prost::alloc::vec::Vec<Keygen>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeygenType {
    UnknownKeygen = 0,
    AsgardKeygen = 1,
}
impl KeygenType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownKeygen => "UnknownKeygen",
            Self::AsgardKeygen => "AsgardKeygen",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnknownKeygen" => Some(Self::UnknownKeygen),
            "AsgardKeygen" => Some(Self::AsgardKeygen),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTssPool {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pool_pub_key: ::prost::alloc::string::String,
    #[prost(enumeration = "KeygenType", tag = "3")]
    pub keygen_type: i32,
    #[prost(string, repeated, tag = "4")]
    pub pub_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "5")]
    pub height: i64,
    #[prost(message, optional, tag = "6")]
    pub blame: ::core::option::Option<Blame>,
    #[prost(string, repeated, tag = "7")]
    pub chains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "8")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "9")]
    pub keygen_time: i64,
    #[prost(bytes = "vec", tag = "10")]
    pub keyshares_backup: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "11")]
    pub secp256k1_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgOutboundTx {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<ObservedTx>,
    #[prost(string, tag = "2")]
    pub in_tx_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnBond {
    #[prost(message, optional, tag = "1")]
    pub tx_in: ::core::option::Option<super::common::Tx>,
    #[prost(bytes = "vec", tag = "2")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub bond_address: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub amount: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "7")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub bond_provider_address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    #[prost(int64, tag = "1")]
    pub height: i64,
    #[prost(string, tag = "2")]
    pub info: ::prost::alloc::string::String,
}
/// UpgradeProposal is the storage format for the upgrade proposal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeProposal {
    #[prost(int64, tag = "1")]
    pub height: i64,
    #[prost(string, tag = "2")]
    pub info: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub proposer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgProposeUpgrade {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub upgrade: ::core::option::Option<Upgrade>,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgApproveUpgrade {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRejectUpgrade {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetVersion {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgWasmExec {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub contract: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub msg: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgWithdrawLiquidity {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(string, tag = "2")]
    pub withdraw_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub basis_points: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(message, optional, tag = "5")]
    pub withdrawal_asset: ::core::option::Option<super::common::Asset>,
    #[prost(bytes = "vec", tag = "6")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolResponse {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub short_code: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub decimals: i64,
    #[prost(string, tag = "5")]
    pub pending_inbound_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub pending_inbound_rune: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub balance_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub balance_rune: ::prost::alloc::string::String,
    /// the USD (TOR) price of the asset in 1e8
    #[prost(string, tag = "9")]
    pub asset_tor_price: ::prost::alloc::string::String,
    /// the total pool units, this is the sum of LP and synth units
    #[prost(string, tag = "10")]
    pub pool_units: ::prost::alloc::string::String,
    /// the total pool liquidity provider units
    #[prost(string, tag = "11")]
    pub lp_units: ::prost::alloc::string::String,
    /// the total synth units in the pool
    #[prost(string, tag = "12")]
    pub synth_units: ::prost::alloc::string::String,
    /// the total supply of synths for the asset
    #[prost(string, tag = "13")]
    pub synth_supply: ::prost::alloc::string::String,
    /// the balance of L1 asset deposited into the Savers Vault
    #[prost(string, tag = "14")]
    pub savers_depth: ::prost::alloc::string::String,
    /// the number of units owned by Savers
    #[prost(string, tag = "15")]
    pub savers_units: ::prost::alloc::string::String,
    /// the filled savers capacity in basis points, 4500/10000 = 45%
    #[prost(string, tag = "16")]
    pub savers_fill_bps: ::prost::alloc::string::String,
    /// amount of remaining capacity in asset
    #[prost(string, tag = "17")]
    pub savers_capacity_remaining: ::prost::alloc::string::String,
    /// whether additional synths cannot be minted
    #[prost(bool, tag = "18")]
    pub synth_mint_paused: bool,
    /// the amount of synth supply remaining before the current max supply is reached
    #[prost(string, tag = "19")]
    pub synth_supply_remaining: ::prost::alloc::string::String,
    /// the amount of collateral collects for loans
    #[prost(string, tag = "20")]
    pub loan_collateral: ::prost::alloc::string::String,
    /// the amount of remaining collateral collects for loans
    #[prost(string, tag = "21")]
    pub loan_collateral_remaining: ::prost::alloc::string::String,
    /// the current loan collateralization ratio
    #[prost(string, tag = "22")]
    pub loan_cr: ::prost::alloc::string::String,
    /// the depth of the derived virtual pool relative to L1 pool (in basis points)
    #[prost(string, tag = "23")]
    pub derived_depth_bps: ::prost::alloc::string::String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOraclePriceRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OraclePrice {
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub price: ::prost::alloc::string::String,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOraclePriceResponse {
    #[prost(message, optional, tag = "1")]
    pub price: ::core::option::Option<OraclePrice>,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<QueryPoolResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDerivedPoolRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDerivedPoolResponse {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub decimals: i64,
    #[prost(string, tag = "4")]
    pub balance_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub balance_rune: ::prost::alloc::string::String,
    /// the depth of the derived virtual pool relative to L1 pool (in basis points)
    #[prost(string, tag = "6")]
    pub derived_depth_bps: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDerivedPoolsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDerivedPoolsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<QueryDerivedPoolResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityProviderRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub height: ::prost::alloc::string::String,
}
/// Can we replace this with LiquidityProvider proto? Check json fields...
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityProviderResponse {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub last_add_height: i64,
    #[prost(int64, tag = "5")]
    pub last_withdraw_height: i64,
    #[prost(string, tag = "6")]
    pub units: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub pending_rune: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub pending_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub pending_tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub rune_deposit_value: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub asset_deposit_value: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub rune_redeem_value: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub asset_redeem_value: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub luvi_deposit_value: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub luvi_redeem_value: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub luvi_growth_pct: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityProvidersRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLiquidityProvidersResponse {
    #[prost(message, repeated, tag = "1")]
    pub liquidity_providers: ::prost::alloc::vec::Vec<QueryLiquidityProviderResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySaverRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySaverResponse {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub last_add_height: i64,
    #[prost(int64, tag = "4")]
    pub last_withdraw_height: i64,
    #[prost(string, tag = "5")]
    pub units: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub asset_deposit_value: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub asset_redeem_value: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub growth_pct: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySaversRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySaversResponse {
    #[prost(message, repeated, tag = "1")]
    pub savers: ::prost::alloc::vec::Vec<QuerySaverResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBorrowerRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBorrowerResponse {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub debt_issued: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub debt_repaid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub debt_current: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub collateral_deposited: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub collateral_withdrawn: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub collateral_current: ::prost::alloc::string::String,
    #[prost(int64, tag = "9")]
    pub last_open_height: i64,
    #[prost(int64, tag = "10")]
    pub last_replay_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBorrowersRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBorrowersResponse {
    #[prost(message, repeated, tag = "1")]
    pub borrowers: ::prost::alloc::vec::Vec<QueryBorrowerResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeUnitRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeUnitResponse {
    /// trade account asset with \"~\" separator
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    /// total units of trade asset
    #[prost(string, tag = "2")]
    pub units: ::prost::alloc::string::String,
    /// total depth of trade asset
    #[prost(string, tag = "3")]
    pub depth: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeUnitsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeUnitsResponse {
    #[prost(message, repeated, tag = "1")]
    pub trade_units: ::prost::alloc::vec::Vec<QueryTradeUnitResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeAccountRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeAccountResponse {
    /// trade account asset with \"~\" separator
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    /// units of trade asset belonging to this owner
    #[prost(string, tag = "2")]
    pub units: ::prost::alloc::string::String,
    /// thor address of trade account owner
    #[prost(string, tag = "3")]
    pub owner: ::prost::alloc::string::String,
    /// last thorchain height trade assets were added to trade account
    #[prost(int64, tag = "4")]
    pub last_add_height: i64,
    /// last thorchain height trade assets were withdrawn from trade account
    #[prost(int64, tag = "5")]
    pub last_withdraw_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeAccountsRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTradeAccountsResponse {
    #[prost(message, repeated, tag = "1")]
    pub trade_accounts: ::prost::alloc::vec::Vec<QueryTradeAccountResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNodeRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNodeResponse {
    #[prost(string, tag = "1")]
    pub node_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub pub_key_set: ::core::option::Option<super::common::PubKeySet>,
    /// the consensus pub key for the node
    #[prost(string, tag = "4")]
    pub validator_cons_pub_key: ::prost::alloc::string::String,
    /// the P2PID (:6040/p2pid endpoint) of the node
    #[prost(string, tag = "5")]
    pub peer_id: ::prost::alloc::string::String,
    /// the block height at which the node became active
    #[prost(int64, tag = "6")]
    pub active_block_height: i64,
    /// the block height of the current provided information for the node
    #[prost(int64, tag = "7")]
    pub status_since: i64,
    #[prost(string, tag = "8")]
    pub node_operator_address: ::prost::alloc::string::String,
    /// current node bond
    #[prost(string, tag = "9")]
    pub total_bond: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub bond_providers: ::core::option::Option<NodeBondProviders>,
    /// the set of vault public keys of which the node is a member
    #[prost(string, repeated, tag = "11")]
    pub signer_membership: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "12")]
    pub requested_to_leave: bool,
    /// indicates whether the node has been forced to leave by the network, typically via ban
    #[prost(bool, tag = "13")]
    pub forced_to_leave: bool,
    #[prost(int64, tag = "14")]
    pub leave_height: i64,
    /// the currently set version of the node
    #[prost(string, tag = "15")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub version: ::prost::alloc::string::String,
    /// the accumulated slash points, reset at churn but excessive slash points may carry over
    #[prost(int64, tag = "17")]
    pub slash_points: i64,
    #[prost(message, optional, tag = "18")]
    pub jail: ::core::option::Option<NodeJail>,
    #[prost(string, tag = "19")]
    pub current_award: ::prost::alloc::string::String,
    /// the last observed heights for all chain by the node
    #[prost(message, repeated, tag = "20")]
    pub observe_chains: ::prost::alloc::vec::Vec<ChainHeight>,
    #[prost(message, optional, tag = "21")]
    pub preflight_status: ::core::option::Option<NodePreflightStatus>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNodesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNodesResponse {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<QueryNodeResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeBondProviders {
    #[prost(string, tag = "1")]
    pub node_operator_fee: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub providers: ::prost::alloc::vec::Vec<NodeBondProvider>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeBondProvider {
    #[prost(string, tag = "1")]
    pub bond_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub bond: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeJail {
    #[prost(int64, tag = "1")]
    pub release_height: i64,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainHeight {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePreflightStatus {
    /// the next status of the node
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    /// the reason for the transition to the next status
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub code: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolSlipRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolSlipResponse {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    /// Pool slip for this asset's pool for the current height
    #[prost(int64, tag = "2")]
    pub pool_slip: i64,
    /// Number of stored pool slips contributing to the current stored rollup
    #[prost(int64, tag = "3")]
    pub rollup_count: i64,
    /// Median of rollup snapshots over a long period
    #[prost(int64, tag = "4")]
    pub long_rollup: i64,
    /// Stored sum of pool slips over a number of previous block heights
    #[prost(int64, tag = "5")]
    pub rollup: i64,
    /// Summed pool slips over a number of previous block heights, to checksum the stored rollup
    #[prost(int64, tag = "6")]
    pub summed_rollup: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolSlipsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPoolSlipsResponse {
    #[prost(message, repeated, tag = "1")]
    pub pool_slips: ::prost::alloc::vec::Vec<QueryPoolSlipResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOutboundFeeRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOutboundFeeResponse {
    /// the asset to display the outbound fee for
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    /// the asset's outbound fee, in (1e8-format) units of the asset
    #[prost(string, tag = "2")]
    pub outbound_fee: ::prost::alloc::string::String,
    /// Total RUNE the network has withheld as fees to later cover gas costs for this asset's outbounds
    #[prost(string, tag = "3")]
    pub fee_withheld_rune: ::prost::alloc::string::String,
    /// Total RUNE the network has spent to reimburse gas costs for this asset's outbounds
    #[prost(string, tag = "4")]
    pub fee_spent_rune: ::prost::alloc::string::String,
    /// amount of RUNE by which the fee_withheld_rune exceeds the fee_spent_rune
    #[prost(string, tag = "5")]
    pub surplus_rune: ::prost::alloc::string::String,
    /// dynamic multiplier basis points, based on the surplus_rune, affecting the size of the outbound_fee
    #[prost(string, tag = "6")]
    pub dynamic_multiplier_basis_points: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOutboundFeesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOutboundFeesResponse {
    #[prost(message, repeated, tag = "1")]
    pub outbound_fees: ::prost::alloc::vec::Vec<QueryOutboundFeeResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStreamingSwapRequest {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStreamingSwapResponse {
    /// the hash of a transaction
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    /// how often each swap is made, in blocks
    #[prost(int64, tag = "2")]
    pub interval: i64,
    /// the total number of swaps in a streaming swaps
    #[prost(int64, tag = "3")]
    pub quantity: i64,
    /// the amount of swap attempts so far
    #[prost(int64, tag = "4")]
    pub count: i64,
    /// the block height of the latest swap
    #[prost(int64, tag = "5")]
    pub last_height: i64,
    /// the total number of tokens the swapper wants to receive of the output asset
    #[prost(string, tag = "6")]
    pub trade_target: ::prost::alloc::string::String,
    /// the asset to be swapped from
    #[prost(string, tag = "7")]
    pub source_asset: ::prost::alloc::string::String,
    /// the asset to be swapped to
    #[prost(string, tag = "8")]
    pub target_asset: ::prost::alloc::string::String,
    /// the destination address to receive the swap output
    #[prost(string, tag = "9")]
    pub destination: ::prost::alloc::string::String,
    /// the number of input tokens the swapper has deposited
    #[prost(string, tag = "10")]
    pub deposit: ::prost::alloc::string::String,
    /// the amount of input tokens that have been swapped so far
    #[prost(string, tag = "11")]
    pub r#in: ::prost::alloc::string::String,
    /// the amount of output tokens that have been swapped so far
    #[prost(string, tag = "12")]
    pub out: ::prost::alloc::string::String,
    /// the list of swap indexes that failed
    #[prost(int64, repeated, tag = "13")]
    pub failed_swaps: ::prost::alloc::vec::Vec<i64>,
    /// the list of reasons that sub-swaps have failed
    #[prost(string, repeated, tag = "14")]
    pub failed_swap_reasons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStreamingSwapsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStreamingSwapsResponse {
    #[prost(message, repeated, tag = "1")]
    pub streaming_swaps: ::prost::alloc::vec::Vec<QueryStreamingSwapResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBanRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BanVoter {
    #[prost(bytes = "vec", tag = "1")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub block_height: i64,
    #[prost(string, repeated, tag = "3")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRagnarokRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryRagnarokResponse {
    #[prost(bool, tag = "1")]
    pub in_progress: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRunePoolRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRunePoolResponse {
    #[prost(message, optional, tag = "1")]
    pub pol: ::core::option::Option<Pol>,
    #[prost(message, optional, tag = "2")]
    pub providers: ::core::option::Option<RunePoolProviders>,
    #[prost(message, optional, tag = "3")]
    pub reserve: ::core::option::Option<RunePoolReserve>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pol {
    /// total amount of RUNE deposited into the pools
    #[prost(string, tag = "1")]
    pub rune_deposited: ::prost::alloc::string::String,
    /// total amount of RUNE withdrawn from the pools
    #[prost(string, tag = "2")]
    pub rune_withdrawn: ::prost::alloc::string::String,
    /// total value of protocol's LP position in RUNE value
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
    /// profit and loss of protocol owned liquidity
    #[prost(string, tag = "4")]
    pub pnl: ::prost::alloc::string::String,
    /// current amount of rune deposited
    #[prost(string, tag = "5")]
    pub current_deposit: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunePoolProviders {
    /// the units of RUNEPool owned by providers (including pending)
    #[prost(string, tag = "1")]
    pub units: ::prost::alloc::string::String,
    /// the units of RUNEPool owned by providers that remain pending
    #[prost(string, tag = "2")]
    pub pending_units: ::prost::alloc::string::String,
    /// the amount of RUNE pending
    #[prost(string, tag = "3")]
    pub pending_rune: ::prost::alloc::string::String,
    /// the value of the provider share of the RUNEPool (includes pending RUNE)
    #[prost(string, tag = "4")]
    pub value: ::prost::alloc::string::String,
    /// the profit and loss of the provider share of the RUNEPool
    #[prost(string, tag = "5")]
    pub pnl: ::prost::alloc::string::String,
    /// the current RUNE deposited by providers
    #[prost(string, tag = "6")]
    pub current_deposit: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunePoolReserve {
    /// the units of RUNEPool owned by the reserve
    #[prost(string, tag = "1")]
    pub units: ::prost::alloc::string::String,
    /// the value of the reserve share of the RUNEPool
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// the profit and loss of the reserve share of the RUNEPool
    #[prost(string, tag = "3")]
    pub pnl: ::prost::alloc::string::String,
    /// the current RUNE deposited by the reserve
    #[prost(string, tag = "4")]
    pub current_deposit: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRuneProviderRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRuneProviderResponse {
    #[prost(string, tag = "1")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub units: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub pnl: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub deposit_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub withdraw_amount: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub last_deposit_height: i64,
    #[prost(int64, tag = "8")]
    pub last_withdraw_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRuneProvidersRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRuneProvidersResponse {
    #[prost(message, repeated, tag = "1")]
    pub providers: ::prost::alloc::vec::Vec<QueryRuneProviderResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMimir {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub value: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub signer: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMimirs {
    #[prost(message, repeated, tag = "1")]
    pub mimirs: ::prost::alloc::vec::Vec<NodeMimir>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirValuesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub mimirs: ::prost::alloc::vec::Vec<Mimir>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirWithKeyRequest {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryMimirWithKeyResponse {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirAdminValuesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirAdminValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub admin_mimirs: ::prost::alloc::vec::Vec<Mimir>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirNodesAllValuesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirNodesAllValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub mimirs: ::prost::alloc::vec::Vec<NodeMimir>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirNodesValuesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirNodesValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub mimirs: ::prost::alloc::vec::Vec<Mimir>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirNodeValuesRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMimirNodeValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub node_mimirs: ::prost::alloc::vec::Vec<Mimir>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mimir {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInboundAddressResponse {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub router: ::prost::alloc::string::String,
    /// Returns true if trading is unavailable for this chain, either because trading is halted globally or specifically for this chain
    #[prost(bool, tag = "5")]
    pub halted: bool,
    /// Returns true if trading is paused globally
    #[prost(bool, tag = "6")]
    pub global_trading_paused: bool,
    /// Returns true if trading is paused for this chain
    #[prost(bool, tag = "7")]
    pub chain_trading_paused: bool,
    /// Returns true if LP actions are paused for this chain
    #[prost(bool, tag = "8")]
    pub chain_lp_actions_paused: bool,
    /// The minimum fee rate used by vaults to send outbound TXs. The actual fee rate may be higher. For EVM chains this is returned in gwei (1e9).
    #[prost(string, tag = "9")]
    pub gas_rate: ::prost::alloc::string::String,
    /// Units of the gas_rate.
    #[prost(string, tag = "10")]
    pub gas_rate_units: ::prost::alloc::string::String,
    /// Avg size of outbound TXs on each chain. For UTXO chains it may be larger than average, as it takes into account vault consolidation txs, which can have many vouts
    #[prost(string, tag = "11")]
    pub outbound_tx_size: ::prost::alloc::string::String,
    /// The total outbound fee charged to the user for outbound txs in the gas asset of the chain.
    #[prost(string, tag = "12")]
    pub outbound_fee: ::prost::alloc::string::String,
    /// Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
    #[prost(string, tag = "13")]
    pub dust_threshold: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInboundAddressesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInboundAddressesResponse {
    #[prost(message, repeated, tag = "1")]
    pub inbound_addresses: ::prost::alloc::vec::Vec<QueryInboundAddressResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryVersionRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryVersionResponse {
    /// current version
    #[prost(string, tag = "1")]
    pub current: ::prost::alloc::string::String,
    /// next version (minimum version for a node to become Active)
    #[prost(string, tag = "2")]
    pub next: ::prost::alloc::string::String,
    /// height at which the minimum joining version last changed
    #[prost(int64, tag = "3")]
    pub next_since_height: i64,
    /// querier version
    #[prost(string, tag = "4")]
    pub querier: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryThornameRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryThornameResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub expire_block_height: i64,
    #[prost(string, tag = "3")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub preferred_asset: ::prost::alloc::string::String,
    /// Amount of RUNE currently accrued by this thorname in affiliate fees waiting to be swapped to preferred asset.
    #[prost(string, tag = "5")]
    pub affiliate_collector_rune: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub aliases: ::prost::alloc::vec::Vec<ThornameAlias>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThornameAlias {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInvariantRequest {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInvariantResponse {
    /// The name of the invariant.
    #[prost(string, tag = "1")]
    pub invariant: ::prost::alloc::string::String,
    /// Returns true if the invariant is broken.
    #[prost(bool, tag = "2")]
    pub broken: bool,
    /// Informative message about the invariant result.
    #[prost(string, repeated, tag = "3")]
    pub msg: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInvariantsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInvariantsResponse {
    #[prost(string, repeated, tag = "1")]
    pub invariants: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNetworkRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryNetworkResponse {
    /// total amount of RUNE awarded to node operators
    #[prost(string, tag = "1")]
    pub bond_reward_rune: ::prost::alloc::string::String,
    /// total bonded RUNE
    #[prost(string, tag = "2")]
    pub total_bond_units: ::prost::alloc::string::String,
    /// effective security bond used to determine maximum pooled RUNE
    #[prost(string, tag = "3")]
    pub effective_security_bond: ::prost::alloc::string::String,
    /// total reserve RUNE
    #[prost(string, tag = "4")]
    pub total_reserve: ::prost::alloc::string::String,
    /// Returns true if there exist RetiringVaults which have not finished migrating funds to new ActiveVaults
    #[prost(bool, tag = "5")]
    pub vaults_migrating: bool,
    /// Sum of the gas the network has spent to send outbounds
    #[prost(string, tag = "6")]
    pub gas_spent_rune: ::prost::alloc::string::String,
    /// Sum of the gas withheld from users to cover outbound gas
    #[prost(string, tag = "7")]
    pub gas_withheld_rune: ::prost::alloc::string::String,
    /// Current outbound fee multiplier, in basis points
    #[prost(string, tag = "8")]
    pub outbound_fee_multiplier: ::prost::alloc::string::String,
    /// the outbound transaction fee in rune, converted from the NativeOutboundFeeUSD mimir (after USD fees are enabled)
    #[prost(string, tag = "9")]
    pub native_outbound_fee_rune: ::prost::alloc::string::String,
    /// the native transaction fee in rune, converted from the NativeTransactionFeeUSD mimir (after USD fees are enabled)
    #[prost(string, tag = "10")]
    pub native_tx_fee_rune: ::prost::alloc::string::String,
    /// the thorname register fee in rune, converted from the TNSRegisterFeeUSD mimir (after USD fees are enabled)
    #[prost(string, tag = "11")]
    pub tns_register_fee_rune: ::prost::alloc::string::String,
    /// the thorname fee per block in rune, converted from the TNSFeePerBlockUSD mimir (after USD fees are enabled)
    #[prost(string, tag = "12")]
    pub tns_fee_per_block_rune: ::prost::alloc::string::String,
    /// the rune price in tor
    #[prost(string, tag = "13")]
    pub rune_price_in_tor: ::prost::alloc::string::String,
    /// the tor price in rune
    #[prost(string, tag = "14")]
    pub tor_price_in_rune: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalanceModuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalanceModuleResponse {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "3")]
    pub coins: ::prost::alloc::vec::Vec<super::cosmos::base::v1beta1::Coin>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteSwapRequest {
    #[prost(string, tag = "1")]
    pub from_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub streaming_interval: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub streaming_quantity: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub destination: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub tolerance_bps: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub refund_address: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "9")]
    pub affiliate: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "10")]
    pub affiliate_bps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "11")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteSwapResponse {
    /// the inbound address for the transaction on the source chain
    #[prost(string, tag = "1")]
    pub inbound_address: ::prost::alloc::string::String,
    /// the approximate number of source chain blocks required before processing
    #[prost(int64, tag = "2")]
    pub inbound_confirmation_blocks: i64,
    /// the approximate seconds for block confirmations required before processing
    #[prost(int64, tag = "3")]
    pub inbound_confirmation_seconds: i64,
    /// the number of thorchain blocks the outbound will be delayed
    #[prost(int64, tag = "4")]
    pub outbound_delay_blocks: i64,
    /// the approximate seconds for the outbound delay before it will be sent
    #[prost(int64, tag = "5")]
    pub outbound_delay_seconds: i64,
    #[prost(message, optional, tag = "6")]
    pub fees: ::core::option::Option<QuoteFees>,
    /// the EVM chain router contract address
    #[prost(string, tag = "7")]
    pub router: ::prost::alloc::string::String,
    /// expiration timestamp in unix seconds
    #[prost(int64, tag = "8")]
    pub expiry: i64,
    /// static warning message
    #[prost(string, tag = "9")]
    pub warning: ::prost::alloc::string::String,
    /// chain specific quote notes
    #[prost(string, tag = "10")]
    pub notes: ::prost::alloc::string::String,
    /// Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
    #[prost(string, tag = "11")]
    pub dust_threshold: ::prost::alloc::string::String,
    /// The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
    #[prost(string, tag = "12")]
    pub recommended_min_amount_in: ::prost::alloc::string::String,
    /// the recommended gas rate to use for the inbound to ensure timely confirmation
    #[prost(string, tag = "13")]
    pub recommended_gas_rate: ::prost::alloc::string::String,
    /// the units of the recommended gas rate
    #[prost(string, tag = "14")]
    pub gas_rate_units: ::prost::alloc::string::String,
    /// generated memo for the swap
    #[prost(string, tag = "15")]
    pub memo: ::prost::alloc::string::String,
    /// the amount of the target asset the user can expect to receive after fees
    #[prost(string, tag = "16")]
    pub expected_amount_out: ::prost::alloc::string::String,
    /// the amount of the target asset the user can expect to receive after fees
    #[prost(int64, tag = "17")]
    pub max_streaming_quantity: i64,
    /// the number of blocks the streaming swap will execute over
    #[prost(int64, tag = "18")]
    pub streaming_swap_blocks: i64,
    /// approx the number of seconds the streaming swap will execute over
    #[prost(int64, tag = "19")]
    pub streaming_swap_seconds: i64,
    /// total number of seconds a swap is expected to take (inbound conf + streaming swap + outbound delay)
    #[prost(int64, tag = "20")]
    pub total_swap_seconds: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteSaverDepositRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub affiliate: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4")]
    pub affiliate_bps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "5")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteSaverDepositResponse {
    /// the inbound address for the transaction on the source chain
    #[prost(string, tag = "1")]
    pub inbound_address: ::prost::alloc::string::String,
    /// the approximate number of source chain blocks required before processing
    #[prost(int64, tag = "2")]
    pub inbound_confirmation_blocks: i64,
    /// the approximate seconds for block confirmations required before processing
    #[prost(int64, tag = "3")]
    pub inbound_confirmation_seconds: i64,
    /// the number of thorchain blocks the outbound will be delayed
    #[prost(int64, tag = "4")]
    pub outbound_delay_blocks: i64,
    /// the approximate seconds for the outbound delay before it will be sent
    #[prost(int64, tag = "5")]
    pub outbound_delay_seconds: i64,
    #[prost(message, optional, tag = "6")]
    pub fees: ::core::option::Option<QuoteFees>,
    /// the EVM chain router contract address
    #[prost(string, tag = "7")]
    pub router: ::prost::alloc::string::String,
    /// expiration timestamp in unix seconds
    #[prost(int64, tag = "8")]
    pub expiry: i64,
    /// static warning message
    #[prost(string, tag = "9")]
    pub warning: ::prost::alloc::string::String,
    /// chain specific quote notes
    #[prost(string, tag = "10")]
    pub notes: ::prost::alloc::string::String,
    /// Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
    #[prost(string, tag = "11")]
    pub dust_threshold: ::prost::alloc::string::String,
    /// The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
    #[prost(string, tag = "12")]
    pub recommended_min_amount_in: ::prost::alloc::string::String,
    /// the recommended gas rate to use for the inbound to ensure timely confirmation
    #[prost(string, tag = "13")]
    pub recommended_gas_rate: ::prost::alloc::string::String,
    /// the units of the recommended gas rate
    #[prost(string, tag = "14")]
    pub gas_rate_units: ::prost::alloc::string::String,
    /// generated memo for the deposit
    #[prost(string, tag = "15")]
    pub memo: ::prost::alloc::string::String,
    /// same as expected_amount_deposit, to be deprecated in favour of expected_amount_deposit
    #[prost(string, tag = "16")]
    pub expected_amount_out: ::prost::alloc::string::String,
    /// the amount of the target asset the user can expect to deposit after fees
    #[prost(string, tag = "17")]
    pub expected_amount_deposit: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteSaverWithdrawRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub withdraw_bps: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteSaverWithdrawResponse {
    /// the inbound address for the transaction on the source chain
    #[prost(string, tag = "1")]
    pub inbound_address: ::prost::alloc::string::String,
    /// the approximate number of source chain blocks required before processing
    #[prost(int64, tag = "2")]
    pub inbound_confirmation_blocks: i64,
    /// the approximate seconds for block confirmations required before processing
    #[prost(int64, tag = "3")]
    pub inbound_confirmation_seconds: i64,
    /// the number of thorchain blocks the outbound will be delayed
    #[prost(int64, tag = "4")]
    pub outbound_delay_blocks: i64,
    /// the approximate seconds for the outbound delay before it will be sent
    #[prost(int64, tag = "5")]
    pub outbound_delay_seconds: i64,
    #[prost(message, optional, tag = "6")]
    pub fees: ::core::option::Option<QuoteFees>,
    /// the EVM chain router contract address
    #[prost(string, tag = "7")]
    pub router: ::prost::alloc::string::String,
    /// expiration timestamp in unix seconds
    #[prost(int64, tag = "8")]
    pub expiry: i64,
    /// static warning message
    #[prost(string, tag = "9")]
    pub warning: ::prost::alloc::string::String,
    /// chain specific quote notes
    #[prost(string, tag = "10")]
    pub notes: ::prost::alloc::string::String,
    /// Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
    #[prost(string, tag = "11")]
    pub dust_threshold: ::prost::alloc::string::String,
    /// The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
    #[prost(string, tag = "12")]
    pub recommended_min_amount_in: ::prost::alloc::string::String,
    /// the recommended gas rate to use for the inbound to ensure timely confirmation
    #[prost(string, tag = "13")]
    pub recommended_gas_rate: ::prost::alloc::string::String,
    /// the units of the recommended gas rate
    #[prost(string, tag = "14")]
    pub gas_rate_units: ::prost::alloc::string::String,
    /// generated memo for the withdraw, the client can use this OR send the dust amount
    #[prost(string, tag = "15")]
    pub memo: ::prost::alloc::string::String,
    /// the dust amount of the target asset the user should send to initialize the withdraw, the client can send this OR provide the memo
    #[prost(string, tag = "16")]
    pub dust_amount: ::prost::alloc::string::String,
    /// the amount of the target asset the user can expect to withdraw after fees in 1e8 decimals
    #[prost(string, tag = "17")]
    pub expected_amount_out: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteLoanOpenRequest {
    #[prost(string, tag = "1")]
    pub from_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub min_out: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub destination: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub affiliate: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "7")]
    pub affiliate_bps: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "8")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteLoanOpenResponse {
    /// the inbound address for the transaction on the source chain
    #[prost(string, tag = "1")]
    pub inbound_address: ::prost::alloc::string::String,
    /// the approximate number of source chain blocks required before processing
    #[prost(int64, tag = "2")]
    pub inbound_confirmation_blocks: i64,
    /// the approximate seconds for block confirmations required before processing
    #[prost(int64, tag = "3")]
    pub inbound_confirmation_seconds: i64,
    /// the number of thorchain blocks the outbound will be delayed
    #[prost(int64, tag = "4")]
    pub outbound_delay_blocks: i64,
    /// the approximate seconds for the outbound delay before it will be sent
    #[prost(int64, tag = "5")]
    pub outbound_delay_seconds: i64,
    #[prost(message, optional, tag = "6")]
    pub fees: ::core::option::Option<QuoteFees>,
    /// the EVM chain router contract address
    #[prost(string, tag = "7")]
    pub router: ::prost::alloc::string::String,
    /// expiration timestamp in unix seconds
    #[prost(int64, tag = "8")]
    pub expiry: i64,
    /// static warning message
    #[prost(string, tag = "9")]
    pub warning: ::prost::alloc::string::String,
    /// chain specific quote notes
    #[prost(string, tag = "10")]
    pub notes: ::prost::alloc::string::String,
    /// Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
    #[prost(string, tag = "11")]
    pub dust_threshold: ::prost::alloc::string::String,
    /// The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
    #[prost(string, tag = "12")]
    pub recommended_min_amount_in: ::prost::alloc::string::String,
    /// the recommended gas rate to use for the inbound to ensure timely confirmation
    #[prost(string, tag = "13")]
    pub recommended_gas_rate: ::prost::alloc::string::String,
    /// the units of the recommended gas rate
    #[prost(string, tag = "14")]
    pub gas_rate_units: ::prost::alloc::string::String,
    /// generated memo for the loan open
    #[prost(string, tag = "15")]
    pub memo: ::prost::alloc::string::String,
    /// the amount of the target asset the user can expect to receive after fees in 1e8 decimals
    #[prost(string, tag = "16")]
    pub expected_amount_out: ::prost::alloc::string::String,
    /// the expected collateralization ratio in basis points
    #[prost(string, tag = "17")]
    pub expected_collateralization_ratio: ::prost::alloc::string::String,
    /// the expected amount of collateral increase on the loan
    #[prost(string, tag = "18")]
    pub expected_collateral_deposited: ::prost::alloc::string::String,
    /// the expected amount of TOR debt increase on the loan
    #[prost(string, tag = "19")]
    pub expected_debt_issued: ::prost::alloc::string::String,
    /// The number of blocks involved in the streaming swaps during the open loan process.
    #[prost(int64, tag = "20")]
    pub streaming_swap_blocks: i64,
    /// The approximate number of seconds taken by the streaming swaps involved in the open loan process.
    #[prost(int64, tag = "21")]
    pub streaming_swap_seconds: i64,
    /// The total expected duration for a open loan, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
    #[prost(int64, tag = "22")]
    pub total_open_loan_seconds: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteLoanCloseRequest {
    #[prost(string, tag = "1")]
    pub from_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub min_out: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub repay_bps: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub loan_owner: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQuoteLoanCloseResponse {
    /// the inbound address for the transaction on the source chain
    #[prost(string, tag = "1")]
    pub inbound_address: ::prost::alloc::string::String,
    /// the approximate number of source chain blocks required before processing
    #[prost(int64, tag = "2")]
    pub inbound_confirmation_blocks: i64,
    /// the approximate seconds for block confirmations required before processing
    #[prost(int64, tag = "3")]
    pub inbound_confirmation_seconds: i64,
    /// the number of thorchain blocks the outbound will be delayed
    #[prost(int64, tag = "4")]
    pub outbound_delay_blocks: i64,
    /// the approximate seconds for the outbound delay before it will be sent
    #[prost(int64, tag = "5")]
    pub outbound_delay_seconds: i64,
    #[prost(message, optional, tag = "6")]
    pub fees: ::core::option::Option<QuoteFees>,
    /// the EVM chain router contract address
    #[prost(string, tag = "7")]
    pub router: ::prost::alloc::string::String,
    /// expiration timestamp in unix seconds
    #[prost(int64, tag = "8")]
    pub expiry: i64,
    /// static warning message
    #[prost(string, tag = "9")]
    pub warning: ::prost::alloc::string::String,
    /// chain specific quote notes
    #[prost(string, tag = "10")]
    pub notes: ::prost::alloc::string::String,
    /// Defines the minimum transaction size for the chain in base units (sats, wei, uatom). Transactions with asset amounts lower than the dust_threshold are ignored.
    #[prost(string, tag = "11")]
    pub dust_threshold: ::prost::alloc::string::String,
    /// The recommended minimum inbound amount for this transaction type & inbound asset. Sending less than this amount could result in failed refunds.
    #[prost(string, tag = "12")]
    pub recommended_min_amount_in: ::prost::alloc::string::String,
    /// the recommended gas rate to use for the inbound to ensure timely confirmation
    #[prost(string, tag = "13")]
    pub recommended_gas_rate: ::prost::alloc::string::String,
    /// the units of the recommended gas rate
    #[prost(string, tag = "14")]
    pub gas_rate_units: ::prost::alloc::string::String,
    /// generated memo for the loan close
    #[prost(string, tag = "15")]
    pub memo: ::prost::alloc::string::String,
    /// the amount of collateral asset the user can expect to receive after fees in 1e8 decimals
    #[prost(string, tag = "16")]
    pub expected_amount_out: ::prost::alloc::string::String,
    /// The quantity of the repayment asset to be sent by the user, calculated as the desired percentage of the loan's value, expressed in units of 1e8
    #[prost(string, tag = "17")]
    pub expected_amount_in: ::prost::alloc::string::String,
    /// the expected amount of collateral decrease on the loan
    #[prost(string, tag = "18")]
    pub expected_collateral_withdrawn: ::prost::alloc::string::String,
    /// the expected amount of TOR debt decrease on the loan
    #[prost(string, tag = "19")]
    pub expected_debt_repaid: ::prost::alloc::string::String,
    /// The number of blocks involved in the streaming swaps during the repayment process.
    #[prost(int64, tag = "20")]
    pub streaming_swap_blocks: i64,
    /// The approximate number of seconds taken by the streaming swaps involved in the repayment process.
    #[prost(int64, tag = "21")]
    pub streaming_swap_seconds: i64,
    /// The total expected duration for a repayment, measured in seconds, which includes the time for inbound confirmation, the duration of streaming swaps, and any outbound delays.
    #[prost(int64, tag = "22")]
    pub total_repay_seconds: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuoteFees {
    /// the target asset used for all fees
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    /// affiliate fee in the target asset
    #[prost(string, tag = "2")]
    pub affiliate: ::prost::alloc::string::String,
    /// outbound fee in the target asset
    #[prost(string, tag = "3")]
    pub outbound: ::prost::alloc::string::String,
    /// liquidity fees paid to pools in the target asset
    #[prost(string, tag = "4")]
    pub liquidity: ::prost::alloc::string::String,
    /// total fees in the target asset
    #[prost(string, tag = "5")]
    pub total: ::prost::alloc::string::String,
    /// the swap slippage in basis points
    #[prost(int64, tag = "6")]
    pub slippage_bps: i64,
    /// total basis points in fees relative to amount out
    #[prost(int64, tag = "7")]
    pub total_bps: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConstantValuesRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryConstantValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub int_64_values: ::prost::alloc::vec::Vec<Int64Constants>,
    #[prost(message, repeated, tag = "2")]
    pub bool_values: ::prost::alloc::vec::Vec<BoolConstants>,
    #[prost(message, repeated, tag = "3")]
    pub string_values: ::prost::alloc::vec::Vec<StringConstants>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Int64Constants {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub value: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BoolConstants {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub value: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringConstants {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySwapQueueRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySwapQueueResponse {
    #[prost(message, repeated, tag = "1")]
    pub swap_queue: ::prost::alloc::vec::Vec<MsgSwap>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLastBlocksRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryChainsLastBlockRequest {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryLastBlocksResponse {
    #[prost(message, repeated, tag = "1")]
    pub last_blocks: ::prost::alloc::vec::Vec<ChainsLastBlock>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainsLastBlock {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub last_observed_in: i64,
    #[prost(int64, tag = "3")]
    pub last_signed_out: i64,
    #[prost(int64, tag = "4")]
    pub thorchain: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryVaultRequest {
    #[prost(string, tag = "1")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryVaultResponse {
    #[prost(int64, tag = "1")]
    pub block_height: i64,
    #[prost(string, tag = "2")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub coins: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub status_since: i64,
    /// the list of node public keys which are members of the vault
    #[prost(string, repeated, tag = "7")]
    pub membership: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub chains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "9")]
    pub inbound_tx_count: i64,
    #[prost(int64, tag = "10")]
    pub outbound_tx_count: i64,
    #[prost(int64, repeated, tag = "11")]
    pub pending_tx_block_heights: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "12")]
    pub routers: ::prost::alloc::vec::Vec<VaultRouter>,
    #[prost(message, repeated, tag = "13")]
    pub addresses: ::prost::alloc::vec::Vec<VaultAddress>,
    #[prost(string, repeated, tag = "14")]
    pub frozen: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAsgardVaultsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAsgardVaultsResponse {
    #[prost(message, repeated, tag = "1")]
    pub asgard_vaults: ::prost::alloc::vec::Vec<QueryVaultResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryVaultsPubkeysRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryVaultsPubkeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub asgard: ::prost::alloc::vec::Vec<VaultInfo>,
    #[prost(message, repeated, tag = "2")]
    pub inactive: ::prost::alloc::vec::Vec<VaultInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VaultInfo {
    #[prost(string, tag = "1")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub routers: ::prost::alloc::vec::Vec<VaultRouter>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VaultRouter {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub router: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VaultAddress {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTssTime {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub tss_time: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TssKeygenMetric {
    #[prost(string, tag = "1")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub node_tss_times: ::prost::alloc::vec::Vec<NodeTssTime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TssKeysignMetric {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub node_tss_times: ::prost::alloc::vec::Vec<NodeTssTime>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxStagesRequest {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxStagesResponse {
    #[prost(message, optional, tag = "1")]
    pub inbound_observed: ::core::option::Option<InboundObservedStage>,
    #[prost(message, optional, tag = "2")]
    pub inbound_confirmation_counted: ::core::option::Option<InboundConfirmationCountedStage>,
    #[prost(message, optional, tag = "3")]
    pub inbound_finalised: ::core::option::Option<InboundFinalisedStage>,
    #[prost(message, optional, tag = "4")]
    pub swap_status: ::core::option::Option<SwapStatus>,
    #[prost(message, optional, tag = "5")]
    pub swap_finalised: ::core::option::Option<SwapFinalisedStage>,
    #[prost(message, optional, tag = "6")]
    pub outbound_delay: ::core::option::Option<OutboundDelayStage>,
    #[prost(message, optional, tag = "7")]
    pub outbound_signed: ::core::option::Option<OutboundSignedStage>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxStatusRequest {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxStatusResponse {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, repeated, tag = "2")]
    pub planned_out_txs: ::prost::alloc::vec::Vec<PlannedOutTx>,
    #[prost(message, repeated, tag = "3")]
    pub out_txs: ::prost::alloc::vec::Vec<super::common::Tx>,
    #[prost(message, optional, tag = "4")]
    pub stages: ::core::option::Option<QueryTxStagesResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxRequest {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxResponse {
    #[prost(message, optional, tag = "1")]
    pub observed_tx: ::core::option::Option<QueryObservedTx>,
    /// the thorchain height at which the inbound reached consensus
    #[prost(int64, tag = "2")]
    pub consensus_height: i64,
    /// the thorchain height at which the outbound was finalised
    #[prost(int64, tag = "3")]
    pub finalised_height: i64,
    /// the thorchain height for which the outbound was scheduled
    #[prost(int64, tag = "4")]
    pub outbound_height: i64,
    #[prost(message, optional, tag = "5")]
    pub keysign_metric: ::core::option::Option<TssKeysignMetric>,
}
/// Same as ObservedTx, but changes block_height and finalise_height (openapi spec)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryObservedTx {
    #[prost(message, optional, tag = "1")]
    pub tx: ::core::option::Option<super::common::Tx>,
    #[prost(string, tag = "2")]
    pub status: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub out_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub block_height: i64,
    #[prost(string, repeated, tag = "5")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "6")]
    pub observed_pub_key: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub keysign_ms: i64,
    #[prost(int64, tag = "8")]
    pub finalise_height: i64,
    #[prost(string, tag = "9")]
    pub aggregator: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub aggregator_target: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub aggregator_target_limit: ::prost::alloc::string::String,
}
/// Same as ObservedTxVoter, but changes height (openapi spec)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryObservedTxVoter {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tx: ::core::option::Option<QueryObservedTx>,
    #[prost(int64, tag = "3")]
    pub height: i64,
    #[prost(message, repeated, tag = "4")]
    pub txs: ::prost::alloc::vec::Vec<QueryObservedTx>,
    #[prost(message, repeated, tag = "5")]
    pub actions: ::prost::alloc::vec::Vec<TxOutItem>,
    #[prost(message, repeated, tag = "6")]
    pub out_txs: ::prost::alloc::vec::Vec<super::common::Tx>,
    #[prost(int64, tag = "7")]
    pub finalised_height: i64,
    #[prost(bool, tag = "8")]
    pub updated_vault: bool,
    #[prost(bool, tag = "9")]
    pub reverted: bool,
    #[prost(int64, tag = "10")]
    pub outbound_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxVotersRequest {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PlannedOutTx {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub coin: ::core::option::Option<super::common::Coin>,
    /// returns true if the planned transaction has a refund memo
    #[prost(bool, tag = "4")]
    pub refund: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InboundObservedStage {
    /// returns true if any nodes have observed the transaction (to be deprecated in favour of counts)
    #[prost(bool, tag = "1")]
    pub started: bool,
    /// number of signers for pre-confirmation-counting observations
    #[prost(int64, tag = "2")]
    pub pre_confirmation_count: i64,
    /// number of signers for final observations, after any confirmation counting complete
    #[prost(int64, tag = "3")]
    pub final_count: i64,
    /// returns true if no transaction observation remains to be done
    #[prost(bool, tag = "4")]
    pub completed: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InboundConfirmationCountedStage {
    /// the THORChain block height when confirmation counting began
    #[prost(int64, tag = "1")]
    pub counting_start_height: i64,
    /// the external source chain for which confirmation counting takes place
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    /// the block height on the external source chain when the transaction was observed
    #[prost(int64, tag = "3")]
    pub external_observed_height: i64,
    /// the block height on the external source chain when confirmation counting will be complete
    #[prost(int64, tag = "4")]
    pub external_confirmation_delay_height: i64,
    /// the estimated remaining seconds before confirmation counting completes
    #[prost(int64, tag = "5")]
    pub remaining_confirmation_seconds: i64,
    /// returns true if no transaction confirmation counting remains to be done
    #[prost(bool, tag = "6")]
    pub completed: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InboundFinalisedStage {
    /// returns true if the inbound transaction has been finalised (THORChain agreeing it exists)
    #[prost(bool, tag = "1")]
    pub completed: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwapStatus {
    /// true when awaiting a swap
    #[prost(bool, tag = "1")]
    pub pending: bool,
    #[prost(message, optional, tag = "2")]
    pub streaming: ::core::option::Option<StreamingStatus>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StreamingStatus {
    /// how often each swap is made, in blocks
    #[prost(int64, tag = "1")]
    pub interval: i64,
    /// the total number of swaps in a streaming swaps
    #[prost(int64, tag = "2")]
    pub quantity: i64,
    /// the amount of swap attempts so far
    #[prost(int64, tag = "3")]
    pub count: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SwapFinalisedStage {
    /// (to be deprecated in favor of swap_status) returns true if an inbound transaction's swap (successful or refunded) is no longer pending
    #[prost(bool, tag = "1")]
    pub completed: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutboundDelayStage {
    /// the number of remaining THORChain blocks the outbound will be delayed
    #[prost(int64, tag = "1")]
    pub remaining_delay_blocks: i64,
    /// the estimated remaining seconds of the outbound delay before it will be sent
    #[prost(int64, tag = "2")]
    pub remaining_delay_seconds: i64,
    /// returns true if no transaction outbound delay remains
    #[prost(bool, tag = "3")]
    pub completed: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutboundSignedStage {
    /// THORChain height for which the external outbound is scheduled
    #[prost(int64, tag = "1")]
    pub scheduled_outbound_height: i64,
    /// THORChain blocks since the scheduled outbound height
    #[prost(message, optional, tag = "2")]
    pub blocks_since_scheduled: ::core::option::Option<ProtoInt64>,
    /// returns true if an external transaction has been signed and broadcast (and observed in its mempool)
    #[prost(bool, tag = "3")]
    pub completed: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySwapperCloutRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwapperClout {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub score: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reclaimed: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub spent: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub last_spent_height: i64,
    #[prost(int64, tag = "6")]
    pub last_reclaim_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQueueRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryQueueResponse {
    #[prost(int64, tag = "1")]
    pub swap: i64,
    /// number of signed outbound tx in the queue
    #[prost(int64, tag = "2")]
    pub outbound: i64,
    #[prost(int64, tag = "3")]
    pub internal: i64,
    /// scheduled outbound value in RUNE
    #[prost(string, tag = "4")]
    pub scheduled_outbound_value: ::prost::alloc::string::String,
    /// scheduled outbound clout in RUNE
    #[prost(string, tag = "5")]
    pub scheduled_outbound_clout: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryScheduledOutboundRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPendingOutboundRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOutboundResponse {
    #[prost(message, repeated, tag = "1")]
    pub tx_out_items: ::prost::alloc::vec::Vec<QueryTxOutItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTxOutItem {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub vault_pub_key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub coin: ::core::option::Option<super::common::Coin>,
    #[prost(string, tag = "5")]
    pub memo: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub max_gas: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(int64, tag = "7")]
    pub gas_rate: i64,
    #[prost(string, tag = "8")]
    pub in_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub out_hash: ::prost::alloc::string::String,
    #[prost(int64, tag = "10")]
    pub height: i64,
    /// clout spent in RUNE for the outbound
    #[prost(string, tag = "11")]
    pub clout_spent: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBlockRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBlockResponse {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<BlockResponseId>,
    #[prost(message, optional, tag = "2")]
    pub header: ::core::option::Option<BlockResponseHeader>,
    #[prost(message, repeated, tag = "3")]
    pub begin_block_events: ::prost::alloc::vec::Vec<BlockEvent>,
    #[prost(message, repeated, tag = "4")]
    pub end_block_events: ::prost::alloc::vec::Vec<BlockEvent>,
    #[prost(message, repeated, tag = "5")]
    pub txs: ::prost::alloc::vec::Vec<QueryBlockTx>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockResponseId {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub parts: ::core::option::Option<BlockResponseIdParts>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockResponseIdParts {
    #[prost(int64, tag = "1")]
    pub total: i64,
    #[prost(string, tag = "2")]
    pub hash: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockResponseHeader {
    #[prost(message, optional, tag = "1")]
    pub version: ::core::option::Option<BlockResponseHeaderVersion>,
    #[prost(string, tag = "2")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub height: i64,
    #[prost(string, tag = "4")]
    pub time: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub last_block_id: ::core::option::Option<BlockResponseId>,
    #[prost(string, tag = "6")]
    pub last_commit_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub data_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub validators_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub next_validators_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub consensus_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub app_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub last_results_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub evidence_hash: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub proposer_address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockResponseHeaderVersion {
    #[prost(string, tag = "1")]
    pub block: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub app: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockEvent {
    #[prost(message, repeated, tag = "1")]
    pub event_kv_pair: ::prost::alloc::vec::Vec<EventKeyValuePair>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventKeyValuePair {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBlockTx {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub tx: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub result: ::core::option::Option<BlockTxResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockTxResult {
    #[prost(int64, tag = "1")]
    pub code: i64,
    #[prost(string, tag = "2")]
    pub data: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub log: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub info: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub gas_wanted: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub gas_used: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub events: ::prost::alloc::vec::Vec<BlockEvent>,
    #[prost(string, tag = "8")]
    pub codespace: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTssKeygenMetricRequest {
    #[prost(string, tag = "1")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTssKeygenMetricResponse {
    #[prost(message, repeated, tag = "1")]
    pub metrics: ::prost::alloc::vec::Vec<TssKeygenMetric>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTssMetricRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTssMetricResponse {
    #[prost(message, repeated, tag = "1")]
    pub keygen: ::prost::alloc::vec::Vec<TssKeygenMetric>,
    #[prost(message, optional, tag = "2")]
    pub keysign: ::core::option::Option<TssKeysignMetric>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryKeysignRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryKeysignPubkeyRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pub_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryKeysignResponse {
    #[prost(message, optional, tag = "1")]
    pub keysign: ::core::option::Option<TxOut>,
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryKeygenRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pub_key: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryKeygenResponse {
    #[prost(message, optional, tag = "1")]
    pub keygen_block: ::core::option::Option<KeygenBlock>,
    #[prost(string, tag = "2")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUpgradeProposalRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUpgradeProposalResponse {
    /// the name of the upgrade
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// the block height at which the upgrade will occur
    #[prost(int64, tag = "2")]
    pub height: i64,
    /// the description of the upgrade, typically json with URLs to binaries for use with automation tools
    #[prost(string, tag = "3")]
    pub info: ::prost::alloc::string::String,
    /// whether the upgrade has been approved by the active validators
    #[prost(bool, tag = "4")]
    pub approved: bool,
    /// the percentage of active validators that have approved the upgrade
    #[prost(string, tag = "5")]
    pub approved_percent: ::prost::alloc::string::String,
    /// the amount of additional active validators required to reach quorum for the upgrade
    #[prost(int64, tag = "6")]
    pub validators_to_quorum: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUpgradeProposalsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUpgradeProposalsResponse {
    #[prost(message, repeated, tag = "1")]
    pub upgrade_proposals: ::prost::alloc::vec::Vec<QueryUpgradeProposalResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUpgradeVotesRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeVote {
    #[prost(string, tag = "1")]
    pub node_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vote: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUpgradeVotesResponse {
    #[prost(message, repeated, tag = "1")]
    pub upgrade_votes: ::prost::alloc::vec::Vec<UpgradeVote>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAccountRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAccountResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub account_number: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub sequence: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryExportRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryExportResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub content: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalancesRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBalancesResponse {
    #[prost(message, repeated, tag = "1")]
    pub balances: ::prost::alloc::vec::Vec<Amount>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Amount {
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySecuredAssetRequest {
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySecuredAssetResponse {
    /// bridge account asset with \"-\" separator
    #[prost(string, tag = "1")]
    pub asset: ::prost::alloc::string::String,
    /// total share tokens issued for the pool
    #[prost(string, tag = "2")]
    pub supply: ::prost::alloc::string::String,
    /// total depth of bridge asset
    #[prost(string, tag = "3")]
    pub depth: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySecuredAssetsRequest {
    #[prost(string, tag = "1")]
    pub height: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuerySecuredAssetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<QuerySecuredAssetResponse>,
}
/// MsgEmpty is the return type for all current Msg Server messages
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgEmpty {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AffiliateFeeCollector {
    #[prost(bytes = "vec", tag = "1")]
    pub owner_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub rune_amount: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainContract {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub router: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrataTxVoter {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub block_height: i64,
    #[prost(string, repeated, tag = "4")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pool {
    #[prost(string, tag = "1")]
    pub balance_rune: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub balance_asset: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "4")]
    pub lp_units: ::prost::alloc::string::String,
    #[prost(enumeration = "PoolStatus", tag = "5")]
    pub status: i32,
    #[prost(int64, tag = "10")]
    pub status_since: i64,
    #[prost(int64, tag = "6")]
    pub decimals: i64,
    #[prost(string, tag = "7")]
    pub synth_units: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub pending_inbound_rune: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub pending_inbound_asset: ::prost::alloc::string::String,
}
/// |    State    | Swap | Add   | Withdraw  | Refunding |
/// | ----------- | ---- | ----- | --------- | --------- |
/// | `staged`    | no   | yes   | yes       | Refund Invalid Add/Remove Liquidity && all Swaps |
/// | `available` | yes  | yes   | yes       | Refund Invalid Tx |
/// | `suspended` | no   | no    | no        | Refund all |
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PoolStatus {
    UnknownPoolStatus = 0,
    Available = 1,
    Staged = 2,
    Suspended = 3,
}
impl PoolStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownPoolStatus => "UnknownPoolStatus",
            Self::Available => "Available",
            Self::Staged => "Staged",
            Self::Suspended => "Suspended",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnknownPoolStatus" => Some(Self::UnknownPoolStatus),
            "Available" => Some(Self::Available),
            "Staged" => Some(Self::Staged),
            "Suspended" => Some(Self::Suspended),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolMod {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub rune_amt: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub rune_add: bool,
    #[prost(string, tag = "4")]
    pub asset_amt: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub asset_add: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventLimitOrder {
    #[prost(message, optional, tag = "1")]
    pub source: ::core::option::Option<super::common::Coin>,
    #[prost(message, optional, tag = "2")]
    pub target: ::core::option::Option<super::common::Coin>,
    #[prost(string, tag = "3")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventStreamingSwap {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub interval: u64,
    #[prost(uint64, tag = "3")]
    pub quantity: u64,
    #[prost(uint64, tag = "4")]
    pub count: u64,
    #[prost(int64, tag = "5")]
    pub last_height: i64,
    #[prost(string, tag = "6")]
    pub trade_target: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "7")]
    pub deposit: ::core::option::Option<super::common::Coin>,
    #[prost(message, optional, tag = "8")]
    pub r#in: ::core::option::Option<super::common::Coin>,
    #[prost(message, optional, tag = "9")]
    pub out: ::core::option::Option<super::common::Coin>,
    #[prost(uint64, repeated, tag = "10")]
    pub failed_swaps: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "11")]
    pub failed_swap_reasons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSwap {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub swap_target: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub swap_slip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub liquidity_fee: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub liquidity_fee_in_rune: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub in_tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "7")]
    pub out_txs: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "8")]
    pub emit_asset: ::core::option::Option<super::common::Coin>,
    #[prost(string, tag = "9")]
    pub synth_units: ::prost::alloc::string::String,
    #[prost(uint64, tag = "10")]
    pub streaming_swap_quantity: u64,
    #[prost(uint64, tag = "11")]
    pub streaming_swap_count: u64,
    #[prost(string, tag = "12")]
    pub pool_slip: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventAddLiquidity {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub provider_units: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub asset_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub rune_tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub asset_tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub asset_address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventWithdraw {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub provider_units: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub basis_points: i64,
    #[prost(bytes = "vec", tag = "4")]
    pub asymmetry: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub in_tx: ::core::option::Option<super::common::Tx>,
    #[prost(string, tag = "6")]
    pub emit_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub emit_rune: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPendingLiquidity {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<super::common::Asset>,
    #[prost(enumeration = "PendingLiquidityType", tag = "2")]
    pub pending_type: i32,
    #[prost(string, tag = "3")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub asset_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub rune_tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub asset_tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventDonate {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<super::common::Asset>,
    #[prost(message, optional, tag = "2")]
    pub in_tx: ::core::option::Option<super::common::Tx>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPool {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<super::common::Asset>,
    #[prost(enumeration = "PoolStatus", tag = "2")]
    pub status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PoolAmt {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(int64, tag = "2")]
    pub amount: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRewards {
    #[prost(string, tag = "1")]
    pub bond_reward: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub pool_rewards: ::prost::alloc::vec::Vec<PoolAmt>,
    #[prost(string, tag = "3")]
    pub dev_fund_reward: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub income_burn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRefund {
    #[prost(uint32, tag = "1")]
    pub code: u32,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub in_tx: ::core::option::Option<super::common::Tx>,
    #[prost(message, optional, tag = "4")]
    pub fee: ::core::option::Option<super::common::Fee>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventBond {
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
    #[prost(enumeration = "BondType", tag = "2")]
    pub bond_type: i32,
    #[prost(message, optional, tag = "3")]
    pub tx_in: ::core::option::Option<super::common::Tx>,
    #[prost(bytes = "vec", tag = "4")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub bond_address: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GasPool {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub rune_amt: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub asset_amt: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub count: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventGas {
    #[prost(message, repeated, tag = "1")]
    pub pools: ::prost::alloc::vec::Vec<GasPool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventReserve {
    #[prost(message, optional, tag = "1")]
    pub reserve_contributor: ::core::option::Option<ReserveContributor>,
    #[prost(message, optional, tag = "2")]
    pub in_tx: ::core::option::Option<super::common::Tx>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventScheduledOutbound {
    #[prost(message, optional, tag = "1")]
    pub out_tx: ::core::option::Option<TxOutItem>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSecurity {
    #[prost(string, tag = "1")]
    pub msg: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tx: ::core::option::Option<super::common::Tx>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSlash {
    #[prost(message, optional, tag = "1")]
    pub pool: ::core::option::Option<super::common::Asset>,
    #[prost(message, repeated, tag = "2")]
    pub slash_amount: ::prost::alloc::vec::Vec<PoolAmt>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventErrata {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub pools: ::prost::alloc::vec::Vec<PoolMod>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventFee {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub fee: ::core::option::Option<super::common::Fee>,
    #[prost(string, tag = "3")]
    pub synth_units: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventOutbound {
    #[prost(string, tag = "1")]
    pub in_tx_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub tx: ::core::option::Option<super::common::Tx>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTssKeygenSuccess {
    #[prost(string, tag = "1")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "3")]
    pub height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTssKeygenFailure {
    #[prost(string, tag = "1")]
    pub fail_reason: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_unicast: bool,
    #[prost(string, repeated, tag = "3")]
    pub blame_nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub round: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTssKeygenMetric {
    #[prost(string, tag = "1")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub median_duration_ms: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTssKeysignMetric {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub median_duration_ms: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSlashPoint {
    #[prost(bytes = "vec", tag = "1")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub slash_points: i64,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventPoolBalanceChanged {
    #[prost(message, optional, tag = "1")]
    pub pool_change: ::core::option::Option<PoolMod>,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMintBurn {
    #[prost(enumeration = "MintBurnSupplyType", tag = "1")]
    pub supply: i32,
    #[prost(string, tag = "2")]
    pub denom: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTradeAccountDeposit {
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTradeAccountWithdraw {
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSecuredAssetDeposit {
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSecuredAssetWithdraw {
    #[prost(string, tag = "1")]
    pub amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRunePoolDeposit {
    #[prost(bytes = "vec", tag = "1")]
    pub rune_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub rune_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub units: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRunePoolWithdraw {
    #[prost(bytes = "vec", tag = "1")]
    pub rune_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub basis_points: i64,
    #[prost(string, tag = "3")]
    pub rune_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub units: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub affiliate_basis_pts: i64,
    #[prost(string, tag = "7")]
    pub affiliate_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub affiliate_address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventLoanOpen {
    #[prost(string, tag = "1")]
    pub collateral_deposited: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub collateral_asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub collateralization_ratio: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub debt_issued: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub target_asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "7")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventLoanRepayment {
    #[prost(string, tag = "1")]
    pub collateral_withdrawn: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub collateral_asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub debt_repaid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub tx_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventThorName {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub registration_fee: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub fund_amt: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub expire: i64,
    #[prost(bytes = "vec", tag = "7")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSetMimir {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventSetNodeMimir {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventVersion {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PendingLiquidityType {
    Add = 0,
    Withdraw = 1,
}
impl PendingLiquidityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Add => "add",
            Self::Withdraw => "withdraw",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "add" => Some(Self::Add),
            "withdraw" => Some(Self::Withdraw),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BondType {
    BondPaid = 0,
    BondReturned = 1,
    BondReward = 2,
    BondCost = 3,
}
impl BondType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::BondPaid => "bond_paid",
            Self::BondReturned => "bond_returned",
            Self::BondReward => "bond_reward",
            Self::BondCost => "bond_cost",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "bond_paid" => Some(Self::BondPaid),
            "bond_returned" => Some(Self::BondReturned),
            "bond_reward" => Some(Self::BondReward),
            "bond_cost" => Some(Self::BondCost),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MintBurnSupplyType {
    Mint = 0,
    Burn = 1,
}
impl MintBurnSupplyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Mint => "mint",
            Self::Burn => "burn",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "mint" => Some(Self::Mint),
            "burn" => Some(Self::Burn),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Jail {
    #[prost(bytes = "vec", tag = "1")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub release_height: i64,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LiquidityProvider {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub rune_address: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub asset_address: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub last_add_height: i64,
    #[prost(int64, tag = "5")]
    pub last_withdraw_height: i64,
    #[prost(string, tag = "6")]
    pub units: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub pending_rune: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub pending_asset: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub pending_tx_id: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub rune_deposit_value: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub asset_deposit_value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Loan {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "3")]
    pub debt_issued: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub debt_repaid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub collateral_deposited: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub collateral_withdrawn: ::prost::alloc::string::String,
    #[prost(int64, tag = "9")]
    pub last_open_height: i64,
    #[prost(int64, tag = "10")]
    pub last_repay_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Network {
    #[prost(string, tag = "1")]
    pub bond_reward_rune: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub total_bond_units: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub lp_income_split: i64,
    #[prost(int64, tag = "6")]
    pub node_income_split: i64,
    #[prost(uint64, tag = "7")]
    pub outbound_gas_spent_rune: u64,
    #[prost(uint64, tag = "8")]
    pub outbound_gas_withheld_rune: u64,
}
/// NetworkFee represents the fee rate and typical outbound transaction size. Some chains
/// may have simplifid usage to report the fee as the "fee_rate" and set size to 1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkFee {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub transaction_size: u64,
    #[prost(uint64, tag = "3")]
    pub transaction_fee_rate: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeAccount {
    #[prost(bytes = "vec", tag = "1")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "NodeStatus", tag = "2")]
    pub status: i32,
    #[prost(message, optional, tag = "3")]
    pub pub_key_set: ::core::option::Option<super::common::PubKeySet>,
    #[prost(string, tag = "4")]
    pub validator_cons_pub_key: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub bond: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub active_block_height: i64,
    #[prost(string, tag = "7")]
    pub bond_address: ::prost::alloc::string::String,
    #[prost(int64, tag = "8")]
    pub status_since: i64,
    #[prost(string, repeated, tag = "9")]
    pub signer_membership: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "10")]
    pub requested_to_leave: bool,
    #[prost(bool, tag = "11")]
    pub forced_to_leave: bool,
    #[prost(uint64, tag = "12")]
    pub leave_score: u64,
    #[prost(string, tag = "13")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub version: ::prost::alloc::string::String,
    #[prost(enumeration = "NodeType", tag = "15")]
    pub r#type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BondProvider {
    #[prost(bytes = "vec", tag = "1")]
    pub bond_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub bond: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BondProviders {
    #[prost(bytes = "vec", tag = "1")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub node_operator_fee: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub providers: ::prost::alloc::vec::Vec<BondProvider>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinJoinLast {
    #[prost(int64, tag = "1")]
    pub last_changed_height: i64,
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeStatus {
    Unknown = 0,
    Whitelisted = 1,
    Standby = 2,
    Ready = 3,
    Active = 4,
    Disabled = 5,
}
impl NodeStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "Unknown",
            Self::Whitelisted => "Whitelisted",
            Self::Standby => "Standby",
            Self::Ready => "Ready",
            Self::Active => "Active",
            Self::Disabled => "Disabled",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "Unknown" => Some(Self::Unknown),
            "Whitelisted" => Some(Self::Whitelisted),
            "Standby" => Some(Self::Standby),
            "Ready" => Some(Self::Ready),
            "Active" => Some(Self::Active),
            "Disabled" => Some(Self::Disabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NodeType {
    TypeValidator = 0,
    TypeVault = 1,
    TypeUnknown = 2,
}
impl NodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::TypeValidator => "TypeValidator",
            Self::TypeVault => "TypeVault",
            Self::TypeUnknown => "TypeUnknown",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TypeValidator" => Some(Self::TypeValidator),
            "TypeVault" => Some(Self::TypeVault),
            "TypeUnknown" => Some(Self::TypeUnknown),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePauseChain {
    #[prost(bytes = "vec", tag = "1")]
    pub node_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "2")]
    pub block_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ObservedNetworkFeeVoter {
    #[prost(int64, tag = "1")]
    pub block_height: i64,
    #[prost(int64, tag = "2")]
    pub report_block_height: i64,
    #[prost(string, tag = "3")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "5")]
    pub fee_rate: i64,
    #[prost(int64, tag = "6")]
    pub transaction_size: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtocolOwnedLiquidity {
    #[prost(string, tag = "1")]
    pub rune_deposited: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rune_withdrawn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RagnarokWithdrawPosition {
    #[prost(int64, tag = "1")]
    pub number: i64,
    #[prost(message, optional, tag = "2")]
    pub pool: ::core::option::Option<super::common::Asset>,
}
/// RUNEPool represents ownership of currently active POL.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunePool {
    #[prost(string, tag = "1")]
    pub reserve_units: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pool_units: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rune_deposited: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rune_withdrawn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuneProvider {
    #[prost(bytes = "vec", tag = "1")]
    pub rune_address: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub deposit_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub withdraw_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub units: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub last_deposit_height: i64,
    #[prost(int64, tag = "6")]
    pub last_withdraw_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecuredAsset {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub depth: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SolvencyVoter {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub coins: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(int64, tag = "5")]
    pub height: i64,
    #[prost(int64, tag = "6")]
    pub consensus_block_height: i64,
    #[prost(string, repeated, tag = "7")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamingSwap {
    #[prost(string, tag = "1")]
    pub tx_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub interval: u64,
    #[prost(uint64, tag = "3")]
    pub quantity: u64,
    #[prost(uint64, tag = "4")]
    pub count: u64,
    #[prost(int64, tag = "5")]
    pub last_height: i64,
    #[prost(string, tag = "6")]
    pub trade_target: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub deposit: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub r#in: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub out: ::prost::alloc::string::String,
    #[prost(uint64, repeated, tag = "10")]
    pub failed_swaps: ::prost::alloc::vec::Vec<u64>,
    #[prost(string, repeated, tag = "11")]
    pub failed_swap_reasons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThorNameAlias {
    #[prost(string, tag = "1")]
    pub chain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThorName {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub expire_block_height: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub preferred_asset: ::core::option::Option<super::common::Asset>,
    #[prost(message, repeated, tag = "5")]
    pub aliases: ::prost::alloc::vec::Vec<ThorNameAlias>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradeAccount {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub units: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "4")]
    pub last_add_height: i64,
    #[prost(int64, tag = "5")]
    pub last_withdraw_height: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TradeUnit {
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<super::common::Asset>,
    #[prost(string, tag = "2")]
    pub units: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub depth: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TssVoter {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pool_pub_key: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub pub_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub block_height: i64,
    #[prost(string, repeated, tag = "5")]
    pub chains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "7")]
    pub majority_consensus_block_height: i64,
    #[prost(string, repeated, tag = "8")]
    pub secp256k1_signatures: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TssKeysignFailVoter {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub height: i64,
    #[prost(string, repeated, tag = "6")]
    pub signers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "7")]
    pub round7_count: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vault {
    #[prost(int64, tag = "1")]
    pub block_height: i64,
    #[prost(string, tag = "2")]
    pub pub_key: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub coins: ::prost::alloc::vec::Vec<super::common::Coin>,
    #[prost(enumeration = "VaultType", tag = "4")]
    pub r#type: i32,
    #[prost(enumeration = "VaultStatus", tag = "5")]
    pub status: i32,
    #[prost(int64, tag = "6")]
    pub status_since: i64,
    #[prost(string, repeated, tag = "7")]
    pub membership: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub chains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "9")]
    pub inbound_tx_count: i64,
    #[prost(int64, tag = "10")]
    pub outbound_tx_count: i64,
    #[prost(int64, repeated, tag = "11")]
    pub pending_tx_block_heights: ::prost::alloc::vec::Vec<i64>,
    #[prost(message, repeated, tag = "22")]
    pub routers: ::prost::alloc::vec::Vec<ChainContract>,
    #[prost(string, repeated, tag = "23")]
    pub frozen: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultType {
    UnknownVault = 0,
    AsgardVault = 1,
}
impl VaultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownVault => "UnknownVault",
            Self::AsgardVault => "AsgardVault",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UnknownVault" => Some(Self::UnknownVault),
            "AsgardVault" => Some(Self::AsgardVault),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultStatus {
    InactiveVault = 0,
    ActiveVault = 1,
    RetiringVault = 2,
    InitVault = 3,
}
impl VaultStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InactiveVault => "InactiveVault",
            Self::ActiveVault => "ActiveVault",
            Self::RetiringVault => "RetiringVault",
            Self::InitVault => "InitVault",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "InactiveVault" => Some(Self::InactiveVault),
            "ActiveVault" => Some(Self::ActiveVault),
            "RetiringVault" => Some(Self::RetiringVault),
            "InitVault" => Some(Self::InitVault),
            _ => None,
        }
    }
}
// @@protoc_insertion_point(module)
